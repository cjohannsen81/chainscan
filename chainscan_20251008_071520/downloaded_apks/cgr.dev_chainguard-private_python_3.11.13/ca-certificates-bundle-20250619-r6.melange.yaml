package:
  name: ca-certificates
  version: "20250619"
  epoch: 6
  description: CA certificates from the Mozilla trusted root program
  commit: ba7ece3f2437a8e7fb3a33424a942dbc3f402f0d
  copyright:
    - license: MPL-2.0 AND MIT
  dependencies:
    runtime:
      - merged-usrsbin
      - wolfi-baselayout
  resources: {}
environment:
  contents:
    build_repositories:
      - https://apk.cgr.dev/chainguard
      - https://packages.wolfi.dev/os
    keyring:
      - https://packages.wolfi.dev/os/wolfi-signing.rsa.pub
    packages:
      - binutils=2.45-r1
      - build-base=1-r8
      - busybox=1.37.0-r50
      - ca-certificates-bundle=20250619-r5
      - cyrus-sasl=2.1.28-r44
      - gcc=15.2.0-r1
      - gdbm=1.26-r1
      - git=2.51.0-r1
      - glibc-dev=2.42-r0
      - glibc-locale-posix=2.42-r0
      - glibc=2.42-r0
      - gmp=6.3.0-r8
      - heimdal-libs=7.8.0-r42
      - isl=0.27-r4
      - jitterentropy-library-dev=3.6.3-r2
      - jitterentropy-library=3.6.3-r2
      - keyutils-libs=1.6.3-r37
      - krb5-conf=1.0-r7
      - krb5-libs=1.22.1-r1
      - ld-linux=2.42-r0
      - libatomic=15.2.0-r1
      - libbrotlicommon1=1.1.0-r7
      - libbrotlidec1=1.1.0-r7
      - libbz2-1=1.0.8-r21
      - libcom_err=1.47.3-r1
      - libcrypt1=2.42-r0
      - libcrypto3=3.5.2-r1
      - libcurl-openssl4=8.15.0-r5
      - libexpat1=2.7.1-r3
      - libgcc=15.2.0-r1
      - libgo=15.2.0-r1
      - libgomp=15.2.0-r1
      - libidn2=2.3.8-r3
      - libldap=2.6.10-r5
      - libnghttp2-14=1.67.0-r0
      - libpcre2-8-0=10.46-r0
      - libpsl=0.21.5-r6
      - libquadmath=15.2.0-r1
      - libssl3=3.5.2-r1
      - libstdc++-dev=15.2.0-r1
      - libstdc++=15.2.0-r1
      - libunistring=1.3-r4
      - libverto=0.3.2-r6
      - libxcrypt-dev=4.4.38-r4
      - libxcrypt=4.4.38-r4
      - libzstd1=1.5.7-r3
      - linux-headers=6.16.4-r0
      - make=4.4.1-r8
      - mpc=1.3.1-r7
      - mpfr=4.2.2-r2
      - ncurses-terminfo-base=6.5_p20250621-r1
      - ncurses=6.5_p20250621-r1
      - nss-db=2.42-r0
      - nss-hesiod=2.42-r0
      - openssf-compiler-options=20240627-r27
      - openssl-dev=3.5.2-r1
      - perl=5.42.0-r1
      - pkgconf=2.5.1-r1
      - posix-cc-wrappers=1-r7
      - readline=8.3-r1
      - sqlite-libs=3.50.4-r1
      - wolfi-baselayout=20230201-r23
      - zlib=1.3.1-r51
  accounts:
    run-as: ""
    users:
      - username: build
        uid: 1000
        gid: 1000
        shell: ""
        homedir: /home/build
    groups:
      - groupname: build
        gid: 1000
        members:
          - build
  archs:
    - amd64
  environment:
    GOFLAGS: ""
    GOMODCACHE: /var/cache/melange/gomodcache
    GOPATH: /home/build/.cache/go
    GOTOOLCHAIN: local
    HOME: /home/build
    PYTHONHASHSEED: "0"
pipeline:
  - uses: git-checkout
    with:
      expected-commit: 1ed28eb21ca591b93cd5bfdc4a9c71ca63593dc0
      repository: https://gitlab.alpinelinux.org/alpine/ca-certificates
      tag: "20250619"
    pipeline:
      - runs: |
          #!/bin/sh
          set -e
          msg() { echo "[git checkout]" "$@"; }
          fail() {
          	msg FAIL "$@"
          	exit 1
          }
          vr() {
          	msg "execute:" "$@"
          	"$@"
          }
          process_cherry_picks() {
          	local cpicksf="$1" oifs="$IFS" count=0
          	local fetched_branches=""
          	local sdate=${SOURCE_DATE_EPOCH:-0}
          	if [ "$sdate" -lt 315532800 ]; then
          		msg "Setting commit date to Jan 1, 1980 (SOURCE_DATE_EPOCH found ${SOURCE_DATE_EPOCH})"
          		sdate=315532800
          	fi
          	if [ -z "$cpicksf" ]; then
          		return 0
          	fi
          	if [ ! -f "$cpicksf" ]; then
          		msg "cherry picks input '$cpicksf' is not a file"
          		return 1
          	fi

          	local line="" branch="" hash="" comment=""
          	while IFS= read -r line; do

          		line=${line%%#*}
          		[ -z "$line" ] && continue

          		if ! echo "$line" | grep -q ':'; then
          			msg "Invalid format, expected '[branch/]commit: comment'. Found: $line"
          			return 1
          		fi

          		branch=${line%%:*}
          		comment=${line#*:}
          		comment=$(
          			set -f
          			echo $comment
          		)

          		if [ -z "$comment" ]; then
          			msg "Empty comment for cherry-pick: $line"
          			return 1
          		fi

          		hash=${branch##*/}

          		[ "$branch" != "$hash" ] && branch=${branch%/*} || branch=""

          		if [ -n "$branch" ]; then
          			case " $fetched_branches " in
          			*" $branch "*) ;;
          			*)
          				vr git fetch origin $branch:$branch || {
          					msg "failed to fetch branch $branch"
          					return 1
          				}
          				fetched_branches="$fetched_branches $branch "
          				;;
          			esac
          		fi

          		vr env \
          			GIT_COMMITTER_DATE="@$sdate" \
          			git cherry-pick -x "$hash" || {
          			msg "failed to cherry-pick $hash from branch $branch"
          			return 1
          		}

          		msg "Cherry-picked $hash from $branch with comment: $comment"

          		count=$((count + 1))
          	done <"$cpicksf"

          	if [ $count -gt 0 ]; then
          		msg "applied $count cherry-pick(s). head is now $(git rev-parse HEAD)"
          	fi
          }
          main() {
          	local repo=$1 dest=${2:-.} depth=${3:-"unset"} branch=$4
          	local tag=$5 expcommit=$6 recurse=${7:-false}
          	local cherry_pick="$8"
          	msg "repo='$repo' dest='$dest' depth='$depth' branch='$branch'" \
          		"tag='$tag' expcommit='$expcommit' recurse='$recurse'"

          	case "$recurse" in
          	true | false) : ;;
          	*) fail "recurse must be true or false, not '$recurse'" ;;
          	esac

          	[ -n "$repo" ] || fail "repository not provided"

          	if [ -z "$branch" ] && [ -z "$tag" ]; then
          		msg "Warning: you have not specified a branch or tag."
          	elif [ -n "$branch" ] && [ -n "$tag" ]; then
          		fail "both branch ($branch) and tag ($tag) are specified."
          	fi

          	[ -n "$expcommit" ] ||
          		msg "Warning: no expected-commit"

          	local flags="" depthflag="" dest_fullpath="" workdir=""
          	local remote="origin" rcfile="" rc="" quiet="--quiet"
          	flags="--config=advice.detachedHead=false"
          	[ -n "$branch" ] && flags="$flags --branch=$branch"
          	[ -n "$tag" ] && flags="$flags --branch=$tag"
          	[ "$recurse" = "true" ] && flags="$flags --recurse-submodules"

          	if [ "$depth" = "unset" ]; then
          		depth=1
          		if [ -n "$branch" -a -n "$expcommit" ]; then

          			depth=-1
          		fi
          	fi

          	[ "$depth" = "-1" ] || depthflag="--depth=$depth"

          	workdir=$(mktemp -d)
          	rcfile=$(mktemp)
          	mkdir -p "$dest"
          	dest_fullpath=$(realpath "$dest")

          	vr git config --global --add safe.directory "$workdir"
          	vr git config --global --add safe.directory "$dest_fullpath"

          	vr git clone $quiet "--origin=$remote" \
          		"--config=user.name=Melange Build" \
          		"--config=user.email=melange-build@cgr.dev" \
          		$flags \
          		${depthflag:+"$depthflag"} "$repo" "$workdir"

          	vr cd "$workdir"
          	msg "tar -c . | tar -C \"$dest_fullpath\" -x"
          	(
          		tar -c .
          		echo $? >"$rcfile"
          	) | tar -C "$dest_fullpath" -x --no-same-owner
          	read rc <"$rcfile" || fail "failed to read rc file"
          	[ $rc -eq 0 ] || fail "tar creation in $workdir failed"

          	rm -rf "$workdir"
          	vr cd "$dest_fullpath"
          	vr git config --global --add safe.directory "$dest_fullpath"

          	local foundcommit="" tagobj=""
          	if [ -z "$tag" ]; then
          		foundcommit=$(git rev-parse --verify HEAD)
          		if [ -n "$expcommit" ] && [ "$expcommit" != "$foundcommit" ]; then
          			if [ "$depth" = "-1" ]; then
          				msg "expected commit $expcommit on ${branch:-HEAD}," \
          					"got $foundcommit, performing reset"
          				vr git reset --hard "$expcommit"
          			else
          				fail "expected commit $expcommit on ${branch:-HEAD}," \
          					"got $foundcommit, set depth to -1 to attempt a reset"
          			fi
          		fi
          		msg "tip of ${branch:-HEAD} is commit $foundcommit"
          		process_cherry_picks "$cherry_pick" || fail "failed to apply cherry-pick"
          		return 0
          	fi

          	vr git fetch $quiet $remote ${depthflag:-"$depthflag"} --no-tags \
          		"+refs/tags/$tag:refs/$remote/tags/$tag"
          	vr git checkout $quiet "$remote/tags/$tag"

          	foundcommit=$(git rev-parse --verify HEAD)
          	if [ -z "$expcommit" ] || [ "$expcommit" = "$foundcommit" ]; then
          		msg "tag $tag is $foundcommit"
          	else

          		tagobj=$(git rev-parse --verify --end-of-options \
          			"refs/$remote/tags/$tag")
          		if [ "$expcommit" != "$tagobj" ]; then
          			[ "$tagobj" != "$expcommit" ] &&
          				msg "tag object hash was $tagobj"
          			fail "Expected commit $expcommit for $tag, found $foundcommit"
          		fi

          		msg "Warning: The provided expected-commit ($expcommit)"
          		msg "was the hash of the annotated tag object for $tag."
          		msg "Update to set expected-commit to $foundcommit"
          	fi

          	process_cherry_picks "$cherry_pick" ||
          		fail "failed to apply cherry-pick"

          	return 0
          }
          cpickf=$(mktemp) || {
          	echo "failed mktemp"
          	exit 1
          }
          cat >"$cpickf" <<"END_CHERRY_PICKS"

          END_CHERRY_PICKS
          main \
          	"https://gitlab.alpinelinux.org/alpine/ca-certificates" "." \
          	"unset" "" \
          	"20250619" "1ed28eb21ca591b93cd5bfdc4a9c71ca63593dc0" \
          	"false" "$cpickf"
          rm -f "$cpickf"
  - runs: |
      make CC="x86_64-pc-linux-gnu-gcc"
  - runs: |
      make install DESTDIR="/home/build/melange-out/ca-certificates"
      mv /home/build/melange-out/ca-certificates/usr/sbin/* /home/build/melange-out/ca-certificates/usr/bin/
      rmdir /home/build/melange-out/ca-certificates/usr/sbin
      (
      	echo "# Automatically generated by ca-certificates-20250619-r6"
      	echo "# Do not edit."
      	cd "/home/build/melange-out/ca-certificates"/usr/share/ca-certificates || exit
      	find . -name '*.crt' | sort | cut -b3-
      ) >"/home/build/melange-out/ca-certificates"/etc/ca-certificates.conf
      find . -maxdepth 1 -name '*.crt' | sort | while read -r i; do
      	cat "$i"
      	printf "\n"
      done >"/home/build/melange-out/ca-certificates"/etc/ssl/certs/ca-certificates.crt
      mkdir -p "/home/build/melange-out/ca-certificates"/etc/apk/protected_paths.d
      cat >"/home/build/melange-out/ca-certificates"/etc/apk/protected_paths.d/ca-certificates.list <<-EOF
      	  -etc/ssl/certs/ca-certificates.crt
      	  -etc/ssl/certs/ca-cert-*.pem
      	  -etc/ssl/certs/[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f].[r0-9]*
      EOF
      cat >"/home/build/melange-out/ca-certificates"/etc/ca-certificates/update.d/certhash <<-EOF
      	  #!/bin/sh
      	  exec /usr/bin/c_rehash /etc/ssl/certs
      EOF
      chmod +x "/home/build/melange-out/ca-certificates"/etc/ca-certificates/update.d/certhash
subpackages:
  - name: ca-certificates-bundle
    pipeline:
      - runs: |
          mkdir -p "/home/build/melange-out/ca-certificates-bundle"/etc/ssl/certs
          mv "/home/build/melange-out/ca-certificates"/etc/ssl/certs/ca-certificates.crt "/home/build/melange-out/ca-certificates-bundle"/etc/ssl/certs
          ln -s certs/ca-certificates.crt "/home/build/melange-out/ca-certificates-bundle"/etc/ssl/cert.pem
          mkdir -p /home/build/melange-out/ca-certificates-bundle/etc/pki/tls/certs/
          ln -s ../../../ssl/certs/ca-certificates.crt /home/build/melange-out/ca-certificates-bundle/etc/pki/tls/certs/ca-bundle.crt
          mkdir -p /home/build/melange-out/ca-certificates-bundle/etc/ssl/certs/
          ln -s ca-certificates.crt /home/build/melange-out/ca-certificates-bundle/etc/ssl/certs/ca-bundle.crt
    dependencies:
      runtime:
        - merged-usrsbin
        - wolfi-baselayout
    commit: ba7ece3f2437a8e7fb3a33424a942dbc3f402f0d
    test:
      environment:
        contents:
          packages:
            - ca-certificates-bundle
        accounts:
          run-as: ""
          users:
            - username: build
              uid: 1000
              gid: 1000
              shell: ""
              homedir: ""
          groups:
            - groupname: build
              gid: 1000
              members:
                - build
      pipeline:
        - name: test for certs directory
          runs: |
            if [ -d "/etc/ssl/certs" ]; then
            	echo "certs directory exists"
            else
            	echo "certs directory does not exist"
            	exit 1
            fi
        - name: test for cert.pem file
          runs: |
            if [ -s "/etc/ssl/cert.pem" ]; then
            	echo "file exists and contains contents."
            else
            	echo "cert.pem file does not exist or is empty"
            	exit 1
            fi
        - name: test for ca-bundle.crt file
          runs: |
            if [ -s "/etc/pki/tls/certs/ca-bundle.crt" ]; then
            	echo "file exists and contains contents."
            else
            	echo "ca-bundle.crt file does not exist or is empty"
            	exit 1
            fi
  - name: ca-certificates-bundle-ecs
    pipeline:
      - runs: |
          mkdir -p "/home/build/melange-out/ca-certificates-bundle-ecs"/var/lib/ecs/deps/execute-command/certs
          cp /home/build/melange-out/ca-certificates-bundle/etc/ssl/certs/ca-certificates.crt "/home/build/melange-out/ca-certificates-bundle-ecs"/var/lib/ecs/deps/execute-command/certs/tls-ca-bundle.pem
    description: CA certificates bundle needed for Amazon ECS exec
    commit: ba7ece3f2437a8e7fb3a33424a942dbc3f402f0d
    test:
      environment:
        contents:
          packages:
            - ca-certificates-bundle-ecs
        accounts:
          run-as: ""
          users:
            - username: build
              uid: 1000
              gid: 1000
              shell: ""
              homedir: ""
          groups:
            - groupname: build
              gid: 1000
              members:
                - build
      pipeline:
        - name: test for certs directory
          runs: |
            if [ -d "/var/lib/ecs/deps/execute-command/certs" ]; then
            	echo "certs directory exists"
            else
            	echo "certs directory does not exist"
            	exit 1
            fi
        - name: test for tls-ca-bundle.pem file
          runs: |
            if [ -s "/var/lib/ecs/deps/execute-command/certs/tls-ca-bundle.pem" ]; then
            	echo "file exists and contains contents."
            else
            	echo "tls-ca-bundle.pem file does not exist or is empty"
            	exit 1
            fi
  - name: ca-certificates-doc
    pipeline:
      - uses: split/manpages
        pipeline:
          - runs: |
              PACKAGE_DIR="/home/build/melange-out/ca-certificates"
              if [ -n "" ]; then
              	PACKAGE_DIR="/home/build/melange-out/"
              fi
              if [ "$PACKAGE_DIR" = "/home/build/melange-out/ca-certificates-doc" ]; then
              	echo "ERROR: Package can not split files from itself!" && exit 1
              fi
              for mandir in \
              	"$PACKAGE_DIR/usr/share/man" \
              	"$PACKAGE_DIR/usr/local/share/man" \
              	"$PACKAGE_DIR/usr/man"; do

              	if [ -d "$mandir" ]; then
              		mkdir -p "/home/build/melange-out/ca-certificates-doc/usr/share/man"
              		mv "$mandir"/* "/home/build/melange-out/ca-certificates-doc/usr/share/man/"
              		rmdir --parents --ignore-fail-on-non-empty "$mandir"
              	fi
              done
    description: ca-certificates documentation
    commit: ba7ece3f2437a8e7fb3a33424a942dbc3f402f0d
    test:
      environment:
        contents:
          packages:
            - apk-tools
            - ca-certificates-doc
            - grep
            - man-db
            - texinfo
        accounts:
          run-as: ""
          users:
            - username: build
              uid: 1000
              gid: 1000
              shell: ""
              homedir: ""
          groups:
            - groupname: build
              gid: 1000
              members:
                - build
      pipeline:
        - uses: test/docs
          pipeline:
            - name: docs readability check
              runs: |
                doc_pkg=$(basename /home/build/melange-out/ca-certificates-doc)
                if [ $(apk info -qL "$doc_pkg" | grep -v "^var/lib/db/sbom" | grep -v "^$" | wc -l) -eq 0 ]; then
                	echo "See:"
                	apk info -qL "$doc_pkg"
                	echo "This package [$doc_pkg] is completely empty (i.e. installs no files)."
                	echo "Please check the package build for proper docs installation, and either:"
                	echo "  (a) fix the docs subpackage build to actually include documentation (check the split/manpages and split/infodir pipelines), or"
                	echo "  (b) remove the test/docs pipeline (if for some reason we want an empty docs package), or"
                	echo "  (c) remove the docs subpackage entirely"
                	exit 1
                fi
                cd /
                doc_files=false
                for doc_file in $(apk info -qL "$doc_pkg" | grep "^usr/share/man/" | grep -v "^usr/share/man/db/"); do
                	if [ -f /"$doc_file" ]; then

                		man -l /"$doc_file" >/dev/null
                		doc_files=true
                	fi
                done
                for doc_file in $(apk info -qL "$doc_pkg" | grep "^usr/share/info/"); do
                	if [ -f /"$doc_file" ]; then

                		[ $(info -f /"$doc_file" -o - | wc -l) -gt 0 ] && doc_files=true
                	fi
                done
                for doc_file in $(apk info -qL "$doc_pkg" | grep "^usr/share/"); do
                	if [ -f /"$doc_file" ]; then

                		cat /"$doc_file" >/dev/null
                		doc_files=true
                	fi
                done
                if [ $doc_files = "false" ]; then
                	echo "See:"
                	apk info -qL "$doc_pkg"
                	echo "This package [$doc_pkg] installs files, but no usable documentation"
                	echo "Please check the package build for proper docs installation, and either:"
                	echo "  (a) fix the docs subpackage build to actually include docs (check the split/manpages and split/infodir pipelines), or"
                	echo "  (b) remove the test/docs pipeline"
                	exit 1
                fi
update:
  enabled: true
  manual: false
  require-sequential: false
  release-monitor:
    identifier: 332224
test:
  environment:
    contents:
      packages:
        - apk-tools
        - ca-certificates
        - curl
        - man-db
    accounts:
      run-as: ""
      users:
        - username: build
          uid: 1000
          gid: 1000
          shell: ""
          homedir: ""
      groups:
        - groupname: build
          gid: 1000
          members:
            - build
  pipeline:
    - runs: |
        ! SSL_CERT_FILE=/dev/null curl --ipv4 -v https://packages.wolfi.dev
        SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt curl --ipv4 -v https://packages.wolfi.dev
        SSL_CERT_FILE=/etc/pki/tls/certs/ca-bundle.crt curl --ipv4 -v https://packages.wolfi.dev
        SSL_CERT_FILE=/etc/ssl/certs/ca-bundle.crt curl --ipv4 -v https://packages.wolfi.dev
        c_rehash -v
        update-ca-certificates --version
        update-ca-certificates --help
    - uses: test/no-docs
      pipeline:
        - name: primary package docs check
          runs: |
            primary_pkg=$(basename /home/build/melange-out/ca-certificates)
            case "$primary_pkg" in
            *-doc)
            	echo "Skipping documentation package [$primary_pkg]"
            	echo "Remove the \"test/no-docs\" pipeline from documentation packages"
            	exit 0
            	;;
            esac
            cd /
            doc_violations=false
            violation_count=0
            has_manpages=false
            has_infodir=false
            default_paths="usr/share/man usr/local/share/man usr/man"
            all_paths="$default_paths"
            if command -v man >/dev/null 2>&1; then
            	for path in $(man --path 2>/dev/null | tr ':' ' '); do
            		clean_path=$(echo "$path" | sed 's|^/||')
            		if [ -n "$clean_path" ]; then

            			path_exists=false
            			for existing_path in $all_paths; do
            				if [ "$clean_path" = "$existing_path" ]; then
            					path_exists=true
            					break
            				fi
            			done

            			if [ "$path_exists" = "false" ]; then
            				all_paths="$all_paths $clean_path"
            			fi
            		fi
            	done
            fi
            man_paths=""
            for path in $all_paths; do
            	if [ -z "$man_paths" ]; then
            		man_paths="^$path/"
            	else
            		man_paths="$man_paths|^$path/"
            	fi
            done
            for doc_file in $(apk info -qL "$primary_pkg" | grep -E "$man_paths"); do
            	if [ -f "/$doc_file" ]; then
            		if [ "$doc_violations" = "false" ]; then
            			echo "Primary package [$primary_pkg] contains documentation files:"
            			doc_violations=true
            		fi
            		has_manpages=true
            		violation_count=$((violation_count + 1))
            		echo "  /$doc_file (manual page)"
            	fi
            done
            for doc_file in $(apk info -qL "$primary_pkg" | grep -E "^usr/share/info/|usr/local/share/info/"); do
            	if [ -f "/$doc_file" ] && [ "$(basename "$doc_file")" != "dir" ]; then
            		if [ "$doc_violations" = "false" ]; then
            			echo "Primary package [$primary_pkg] contains documentation files:"
            			doc_violations=true
            		fi
            		has_infodir=true
            		violation_count=$((violation_count + 1))
            		echo "  /$doc_file (info page)"
            	fi
            done
            if [ "$doc_violations" = "true" ]; then
            	echo ""
            	echo "These files should be moved to a -doc subpackage."
            	echo "Please add the following split pipeline(s):"
            	if [ "$has_manpages" = "true" ]; then
            		echo "  - split/manpages (for manual pages)"
            	fi
            	if [ "$has_infodir" = "true" ]; then
            		echo "  - split/infodir (for GNU info pages)"
            	fi
            	echo ""
            	echo "Total documentation files found: $violation_count"
            	exit 1
            fi
            echo "Primary package [$primary_pkg] does not contain documentation files"
